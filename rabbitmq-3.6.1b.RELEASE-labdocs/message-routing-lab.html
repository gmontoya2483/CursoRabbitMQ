<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;4.&nbsp;Using the Full Routing Capabilities of RabbitMQ</title><link rel="stylesheet" type="text/css" href="css/html.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="RabbitMQ - Lab Documentation"><link rel="up" href="index.html" title="RabbitMQ - Lab Documentation"><link rel="prev" href="java-message-sender-receiver-lab.html" title="Chapter&nbsp;3.&nbsp;Java Message Sender and Receiver"><link rel="next" href="reliable-message-flow-lab.html" title="Chapter&nbsp;5.&nbsp;Building a Reliable Message Flow"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" style="background-color:white;border:none;height:73px;border:none;"><a style="border:none;" href="http://www.rabbitmq.com/" title="RabbitMQ"><img style="border:none;" src="images/rabbitmq_logo_strap.png"></img></a><a style="border:none;" href="http://www.pivotal.io/" title="RabbitMQ by Pivotal"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/logo-pivotal-118x25.png"></img></a></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="message-routing-lab"></a>Chapter&nbsp;4.&nbsp;Using the Full Routing Capabilities of RabbitMQ</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-routing-lab-objective"></a>4.1.&nbsp;Objective</h2></div></div></div><p>In this lab, you will discover the routing capabilities of RabbitMQ. You know by now messages 
        	are sent to exchanges and consumed from queues. This lab is about what can happen between the 
        	exchanges and queues, as they can be bound to each other.</p><p>The lab is made of two parts: first, you&#8217;ll practice with the different types of exchanges 
			from the management plugin. Second, you&#8217;ll implement a couple of typical messaging patterns 
			thanks to RabbitMQ&#8217;s routing features.</p><p>By the end of this lab, you&#8217;ll have strong foundations about the AMQP model and what you 
			can achieve with it in your own systems.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-routing-lab-exchanges-and-bindings"></a>4.2.&nbsp;Exchange Types and Bindings</h2></div></div></div><p>Remember, there are 4 types of exchanges in AMQP: fanout, direct, headers, and 
        	topic. You saw them in the slides, but it&#8217;s always good to practice by yourself 
        	to really understand how things work. In this part, we&#8217;ll see the 4 types of 
        	exchanges one after the other, by sending messages to them and see in which queue(s) 
        	they end up. Let&#8217;s start by defining our queues!</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="message-routing-lab-queue-definitions"></a>4.2.1.&nbsp;Queue Definitions</h3></div></div></div><p>We keep on working with our quotation use case: the queues will represent different stock markets.</p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>From the management web UI, define 4 queues: <code class="code">us</code> (for US stocks), 
						<code class="code">eu</code> (for European stocks), <code class="code">nyse</code> (for US stocks exchanged at New York), 
						and <code class="code">world</code> (for all the stocks).</p></li></ol></div><p>Let&#8217;s start working the simplest kind of exchange: fanout.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="message-routing-lab-fanout"></a>4.2.2.&nbsp;Fanout</h3></div></div></div><p>The fanout does simple broadcasting: it sends messages to all the queues bound to it (a 
				fanout exchange doesn&#8217;t care about the routing key).</p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>Create a <code class="code">stock.fanout</code> exchange of type <code class="code">fanout</code>.</p></li><li class="listitem"><p>Go to the details page of the fanout.</p></li><li class="listitem"><p>Bind the <code class="code">us</code> queue to the exchange.</p></li><li class="listitem"><p>Send a message to the exchange and check it arrived on the us queue</p></li></ol></div><p>Play around with the binding to the queue (specify or not a value for &#8220;Routing key&#8221;) 
				and the routing key of the messages you&#8217;re sending. You&#8217;ll see the messages always 
				arrive to the queue; a fanout doesn&#8217;t care about the routing key!</p><p>Let's bind other queues:</p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>Bind the <code class="code">eu</code> and <code class="code">world</code> queues to the fanout.</p></li><li class="listitem"><p>Send messages to the exchange and check they all arrive on the queues.</p></li></ol></div><p>You can purge the queues and remove the bindings.</p><p>OK, enough with the fanout for now, let&#8217;s work with a direct exchange!</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="message-routing-lab-direct"></a>4.2.3.&nbsp;Direct</h3></div></div></div><p>The direct exchange uses the routing key of a message to route to a queue bound with the same key.</p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>Create a <code class="code">stock.direct</code> exchange of type <code class="code">direct</code>.</p></li><li class="listitem"><p>Bind the <code class="code">eu</code> queue to the exchange with the routing key <code class="code">market.eu</code>.</p></li><li class="listitem"><p>Bind the <code class="code">us</code> queue to the exchange with the routing key <code class="code">market.us</code>.</p></li><li class="listitem"><p>Send a message with the routing key <code class="code">market.eu</code> and check it 
						ends up in the <code class="code">eu</code> queue.</p></li><li class="listitem"><p>Send a message with the routing key <code class="code">market.us</code> and check it 
						ends up in the <code class="code">us</code> queue.</p></li><li class="listitem"><p>Send a message with the routing key <code class="code">market.world</code> and check it 
						is dropped.</p></li></ol></div><p>So far, so good, but wouldn&#8217;t it be great if the world queue could also receive messages?</p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>Create 2 new bindings to the world queue: one with <code class="code">market.us</code> for 
						the routing key and another with <code class="code">market.eu</code> for the routing key.</p></li><li class="listitem"><p>Send messages with <code class="code">market.us</code> and <code class="code">market.eu</code> for the routing 
						keys and check where they end up.</p></li></ol></div><p>OK, we&#8217;re done with the direct exchange. Clean up the queues before moving on to the 
				next type of exchange.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="message-routing-lab-headers"></a>4.2.4.&nbsp;Headers</h3></div></div></div><p>A headers exchange ignores the routing key, it works against headers in the message 
				that it matches with arguments specified in the binding.</p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>Create a <code class="code">stock.headers</code> exchange of type <code class="code">headers</code>.</p></li><li class="listitem"><p>Bind the <code class="code">eu</code> queue, specify no routing key, and add a parameter 
						<code class="code">market</code> with value <code class="code">eu</code>.</p></li><li class="listitem"><p>Bind the <code class="code">us</code> queue, specify no routing key, and add a parameter 
						<code class="code">market</code> with value <code class="code">us</code>.</p></li><li class="listitem"><p>Send a message with a market header equal to <code class="code">eu</code> and check the 
						message arrived on the <code class="code">eu</code> queue.</p></li><li class="listitem"><p>Send a message with a market header equal to <code class="code">us</code> and check the 
						message arrived on the <code class="code">us</code> queue.</p></li></ol></div><p>Like with the direct exchange, you can bind the world queue twice, with two different 
				values for the market header and check messages for the different market places arrive 
				also on the world queue.</p><p>Purge the queues and let&#8217;s see the topic exchange.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="message-routing-lab-topic"></a>4.2.5.&nbsp;Topic</h3></div></div></div><p>The topic exchange is powerful, as it can use wildcards in the routing key 
				to route message to queues.</p><p>Here are some examples of what we want to do with our quotations:</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>A message with a routing key starting with <code class="code">stock.us</code> should 
						go to the <code class="code">us</code> and <code class="code">world</code> queues.</p></li><li class="listitem"><p>A message with a routing key equal to <code class="code">stock.us.nyse</code> should go the 
						<code class="code">nyse</code> queue&#8230; but also to the <code class="code">us</code> and <code class="code">world</code> queues!</p></li><li class="listitem"><p>A message with a routing key starting with <code class="code">stock.eu</code> should go to the 
						<code class="code">eu</code> and <code class="code">world</code> queues.</p></li><li class="listitem"><p>Any message with a routing key starting with <code class="code">stock</code> should go to the 
						<code class="code">world</code> queue.</p></li></ul></div><p>We guided you for the previous bindings, now you&#8217;re on your own. With four bindings, 
				dots, the * and # wildcard, this should be fairly easy!</p><p>When you&#8217;re done, move on to the next part, where you&#8217;ll see exchanges, bindings, and queues in action.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-routing-lab-patterns"></a>4.3.&nbsp;Patterns</h2></div></div></div><p>In this part, we cover a couple of typical messaging patterns. Exchanges, bindings, and 
			queues are just features; they don&#8217;t provide much functionality per-se. Nevertheless, 
			they provide foundations to implement patterns commonly needed and used in messaging applications.</p><p>The patterns covered here are independent; you can choose to focus on only one if 
			you&#8217;re a little short of time.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="message-routing-lab-publish-subscribe"></a>4.3.1.&nbsp;Publish/Subscribe</h3></div></div></div><p>The publish/suscribe pattern consists in delivering a message to multiple consumers. This pattern provides good decoupling: the sender doesn&#8217;t know anything about the consumers (as usual with messaging) and adding a new feature to the system consists in adding a new consumer.</p><p>This pattern can be easily implemented with RabbitMQ thanks to a fanout. Remember you just need to bind a queue to a fanout, so that the messages sent to the fanout end up in the queue. If you bind several queues, the messages are delivered to all of them.</p><p>In our publish/subscribe use case, a producer sends stock quotations every second. One consumer would log these quotations into a file (the &#8220;logger&#8221;), the other consumer would display the last ten quotations in web page (the &#8220;web UI&#8221;).</p><p>Let&#8217;s focus on the sender first.</p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>Open the <code class="code">QuotationSender</code> class and check its content. It sends quotations to an exchange.</p></li><li class="listitem"><p>In the <code class="code">QuotationSender</code> class, write the code to declare the exchange (a fanout), 
						just after the channel creation.</p></li></ol></div><p>Feel free to run the program and to verify it&#8217;s working properly with the management plugin (by creating a 
				dummy queue for example).  STOP IT once you are happy it is working.</p><p>Now let&#8217;s see the file logger.</p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>Open the <code class="code">QuotationLogger</code> class. Some code has already been written for you.</p></li><li class="listitem"><p>Follow the instructions in the code to finish the <code class="code">QuotationLogger</code>.</p></li><li class="listitem"><p>Notice that the <code class="code">QuotationLogger</code> purges its input queue to get rid of old
				messages when it starts up. This means it <span class="emphasis"><em>MUST RUN FIRST</em></span>.</p></li></ol></div><p>Time to run our code to see what happens.  Start the logger <span class="emphasis"><em>FIRST</em></span> and <span class="emphasis"><em>then</em></span> the sender. 
			    Check the log file (it&#8217;s at the root of the  lab project). If you are using STS/Eclipse
			    select the project folder and press F5 (to refresh) forcing it to "see" the new file.
			    Don&#8217;t hesitate to ask to the instructor if something goes wrong.</p><p>When the programs work fine, stop them. Time to focus on the web UI consumer.</p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>Open the <code class="code">QuotationWebUi</code> class. Its job is to memorize the quotation and display 
						the last ten ones in a web page. The web part has already been written for you. Don&#8217;t hesitate 
						to have a look if you&#8217;re curious.</p></li><li class="listitem"><p>Follow the instructions in the code to finish the <code class="code">QuotationWebUi</code>.</p></li></ol></div><p>The <code class="code">QuotationWebUi</code> uses asynchronous consumption. Note our program isn&#8217;t 
				bullet-proof: if it runs a long time, it will consume all the memory, as the quotation 
				collection is never cleaned up (a background thread should clean it up from times to times). 
				It does the job for now!</p><p>Launch the sender and the web UI. Check the web page at the following URL: 
				<a class="ulink" href="http://localhost:8085" target="_top">http://localhost:8085</a>.</p><p>Run the logger at the same time, and the messages will be processed by two consumers 
				at the same. Congratulations, you made it through the publish/subscribe pattern!</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="message-routing-lab-request-reply"></a>4.3.2.&nbsp;Request/Reply (aka RPC)</h3></div></div></div><p>Messaging is very useful for fire-and-forget scenarios: the sender publishes a message 
				and doesn&#8217;t wait any response, at least it doesn&#8217;t need a response to move ahead. But 
				sometimes, the sender needs a response to its request, and RabbitMQ makes this synchronous 
				request/reply scenario possible. The advantage to use RabbitMQ for such a scenario is 
				the sender doesn&#8217;t know anything about who processed its request: it can be any consumer, 
				anywhere. All of this, thanks to the decoupling provided by exchanges and queues.</p><p>The trick to handle request/reply with RabbitMQ is the following: the sender must 
				provide a reply queue in the request message and wait for the response on this queue 
				immediately afterwards he has sent the request. The consumer must be a good citizen 
				and send back the response on the reply queue.</p><p>Our request/reply use case will consist in sending a stock quotation message and 
				wait for a response to know if we should buy some of the stocks (the payload of the response 
				message will contain &#8220;yes&#8221; or &#8220;no&#8221;).</p><p>Let&#8217;s have a look at the sender first.</p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>Open the <code class="code">QuotationSubmitter</code> class.</p></li><li class="listitem"><p>Follow the instructions in the code to finish the <code class="code">QuotationSubmitter</code>.</p></li></ol></div><p>The <code class="code">QuotationSubmitter</code> uses the simplest way to handle the request/reply pattern: 
				it dynamically creates the reply queue. This queue will be used only for the response it awaits. 
				This techniques works but doesn&#8217;t scale with a lot of senders. A more advanced techniques consists 
				in sharing a reply queue between multiple senders and filtering responses thanks to a correlation ID.</p><p>Once you&#8217;re done with the <code class="code">QuotationSubmitter</code>, you can work on the Java program 
				that handles the request and sends back a response.</p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>Open the <code class="code">QuotationOfferDecider</code> class.</p></li><li class="listitem"><p>Follow the instructions in the code to finish the <code class="code">QuotationOfferDecider</code>.</p></li></ol></div><p>The <code class="code">QuotationOfferDecider</code> is a simple asynchronous consumer. Its only purpose 
				is to send a response message immediately afterward the reception.</p><p>It&#8217;s time to test: launch the QuotationOfferDecider and then submit some quotations by launching 
				several times the QuotationSubmitter. You should see the submitter outputting the response of the 
				decider.</p><p>Congratulations, you&#8217;re done with the lab!</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-routing-lab-bonus"></a>4.4.&nbsp;Bonus</h2></div></div></div><p>What if the decider takes a long time to decide and the submitter can&#8217;t actually wait? This 
			is a common requirement: you don&#8217;t want a user or a system to wait too long after a request, 
			5 seconds max for example.  But with distributed systems, it&#8217;s always difficult to estimate 
			the duration of complex processing. So the &#8220;fail fast&#8221; philosophy consists in waiting a given 
			amount of time, giving up if the processing takes too long, and giving back a negative answer 
			to the requester (or something like &#8220;the processing takes too long right now, you&#8217;ll have your 
			response in your mail box ASAP&#8221;). The &#8220;fail fast&#8221; is easy to implement with RabbitMQ. Modify 
			the <code class="code">QuotationSubmitter</code> to wait for only 5 seconds for the response. Output something 
			accordingly on the console. To simulate a long processing on the decider side, add a call 
			to the <code class="code">letsWait()</code> method before publishing the response.</p></div></div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="java-message-sender-receiver-lab.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="reliable-message-flow-lab.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;3.&nbsp;Java Message Sender and Receiver&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.pivotal.io/oss" title="RabbitMQ">RabbitMQ By Pivotal</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;5.&nbsp;Building a Reliable Message Flow</td></tr></table></div></body></html>